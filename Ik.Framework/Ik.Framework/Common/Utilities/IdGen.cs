using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Ik.Framework.Common.Utilities
{
    public static class IdGen
    {

        /// <summary>
        /// This algorithm generates secuential GUIDs across system boundaries, ideal for databases 
        /// </summary>
        /// <returns></returns>
        public static Guid NewSequentialGuid()
        {
            byte[] uid = Guid.NewGuid().ToByteArray();
            byte[] binDate = BitConverter.GetBytes(DateTime.UtcNow.Ticks);

            byte[] secuentialGuid = new byte[uid.Length];

            secuentialGuid[0] = uid[0];
            secuentialGuid[1] = uid[1];
            secuentialGuid[2] = uid[2];
            secuentialGuid[3] = uid[3];
            secuentialGuid[4] = uid[4];
            secuentialGuid[5] = uid[5];
            secuentialGuid[6] = uid[6];

            // set the first part of the 8th byte to '1100' so     
            // later we'll be able to validate it was generated by us   
            secuentialGuid[7] = (byte)(0xc0 | (0xf & uid[7]));

            // the last 8 bytes are sequential,    
            // it minimizes index fragmentation   
            // to a degree as long as there are not a large    
            // number of Secuential-Guids generated per millisecond  
            secuentialGuid[9] = binDate[0];
            secuentialGuid[8] = binDate[1];
            secuentialGuid[15] = binDate[2];
            secuentialGuid[14] = binDate[3];
            secuentialGuid[13] = binDate[4];
            secuentialGuid[12] = binDate[5];
            secuentialGuid[11] = binDate[6];
            secuentialGuid[10] = binDate[7];

            return new Guid(secuentialGuid);
        }

        /// <summary>
        /// 当在很短的时间内生成多个连续的Guid，此时生成的多个DateTime.UtcNow.Ticks可能是一样的
        /// 在这种情况下，是无法保证生成的Guid的连续性。
        /// 所以当需要一次生成多个保证连续性的Guid时，使用此方法
        /// </summary>
        /// <param name="count">生成的数量</param>
        /// <returns></returns>
        public static List<Guid> NewSequentialGuids(int count)
        {
            var ret = new List<Guid>();
            var tick = DateTime.UtcNow.Ticks;
            for (var i = 0; i < count; i++)
            {
                byte[] binDate = BitConverter.GetBytes(tick + i);
                byte[] uid = Guid.NewGuid().ToByteArray();
                byte[] secuentialGuid = new byte[uid.Length];

                secuentialGuid[0] = uid[0];
                secuentialGuid[1] = uid[1];
                secuentialGuid[2] = uid[2];
                secuentialGuid[3] = uid[3];
                secuentialGuid[4] = uid[4];
                secuentialGuid[5] = uid[5];
                secuentialGuid[6] = uid[6];

                // set the first part of the 8th byte to '1100' so     
                // later we'll be able to validate it was generated by us   
                secuentialGuid[7] = (byte)(0xc0 | (0xf & uid[7]));

                // the last 8 bytes are sequential,    
                // it minimizes index fragmentation   
                // to a degree as long as there are not a large    
                // number of Secuential-Guids generated per millisecond  
                secuentialGuid[9] = binDate[0];
                secuentialGuid[8] = binDate[1];
                secuentialGuid[15] = binDate[2];
                secuentialGuid[14] = binDate[3];
                secuentialGuid[13] = binDate[4];
                secuentialGuid[12] = binDate[5];
                secuentialGuid[11] = binDate[6];
                secuentialGuid[10] = binDate[7];

                ret.Add(new Guid(secuentialGuid));
            }
            return ret;
        }
    }
}

#region copyright
/*
*.NET基础开发框架
*Copyright (C) 。。。
*地址：git@github.com:gangzaicd/Ik.Framework.git
*作者：到大叔碗里来（大叔）
*QQ：397754531
*eMail：gangzaicd@163.com
*/
#endregion copyright
